import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import math
#dim gives the size of the environment
dim=200
X=set(range(1,dim+1))
Y=set(range(1,dim+1))
#X_ob and Y_ob are sets which give the coordinates of the obstacles  
X_ob={10,11,12,13}
Y_ob={10,11,12,13} 
X_cl=X-X_ob
Y_cl=Y-Y_ob
#G is just a graph for testing the Nearest function. Later it will be replaced by a graph generated by Sample
#G=nx.Graph()
#G.add_node(2)
#G.add_node(3)
#G.add_edge(1,2)
#G.add_edge(1,3)
#x=4
#Nearest should take in a graph and a node. the node should be a 2d array representing positiona and have an attribute "cost". should return a node
def Nearest(G,x,dim):
	min_dist=dim**3;
	#print(min_dist)
	for node in G.nodes():
		pos_1=[node[0],node[1]]
		pos_2=[x[0],x[1]]
		distance=math.dist(pos_1,pos_2)
		if distance < min_dist:
			nearest=node
			min_dist=distance
	return nearest
#Sample takes in 2 sets and returns a 2d array representing position (no cost)
def Sample(X_cl,Y_cl,dim,n):
	ans=[]
	while len(ans) <n:
		x_test=np.random.randint(1,dim)
		y_test=np.random.randint(1,dim)
		#print(x_test)
		if x_test in X_cl and y_test in Y_cl:
			ans=[x_test,y_test]
	return ans
#should steer have cost?? yes. returns tuple
def Steer(x,y,n):
	a=y[0]-x[0]
	b=y[1]-x[1]
	L=math.sqrt(a*a+b*b)
	if L == 0:
		print('same same')
		print(x)
		print(y)
		print('same same')
		ans=x
	else:
		g=[0,0,0]
		#add floor to just keep integer space
		g[0]=math.floor((n*a/L+x[0]))
		g[1]=math.floor((n*b/L+x[1]))
		pos_1=[x[0],x[1]]
		pos_2=[g[0],g[1]]
		cost=math.dist(pos_1,pos_2)+x[2]
		g[2]=x[2]+cost
		ans=tuple((g[0],g[1],g[2]))
	return ans
#takes in tuples or lists
def ObstacleFree(x,y,X_ob,Y_ob):
	answer=True
	i=0
	stop_x=list(X_ob)
	stop_y=list(Y_ob)
	while i<len(stop_x):
		if(x[0]-y[0])==0:
			if stop_x[i]==x[0] and stop_y[i] > min(x[1],y[1]) and stop_y[i] < max(x[1],y[1]):
				answer=False
		else: 
			m=(x[1]-y[1])/(x[0]-y[0])
			b=m*x[0]-x[1]
			if stop_y[i]==m*stop_x[i]+b:
				answer=False
		i=i+1
	return answer
#WHAT SHOULD NEAR RETURN?? ...maybe a list of tuples? 
def Near(G,x,n,neu):
	pos_x=[x[0],x[1]]
	V_prime=[]
	gamma=1
	r_n=math.sqrt((gamma/math.pi*math.log(n)/n))
	r_n=min(r_n,neu)
	for node in G.nodes():
		pos_node=[node[0],node[1]]
		if math.dist(pos_x,pos_node) < r_n:
			cost=math.dist(pos_x,pos_node)+x[2]
			tup=tuple((pos_node[0],pos_node[1],cost))
			V_prime.append(tup)
	return V_prime
def Extend(R,x_rand,X_ob,Y_ob,n,dim):
	R_prime=R
	x_nearest=Nearest(R,x_rand,dim)
	x_new=Steer(x_nearest,x_rand,3)
	i=0
	if ObstacleFree(x_nearest,x_new,X_ob,Y_ob):
		R_prime.add_node(x_new)
	#	print('added node')
	#
	#	print(x_new)
		x_min=x_nearest
		#remember X_near is a list of tuples
		X_near=Near(R,x_new,R.number_of_nodes(),n)
		#print(X_near)
		while i < len(X_near): #I guess this while loop does nothing if there is a linear 
					#cost function?
			if(ObstacleFree(X_near[i],x_new,X_ob,Y_ob)):
				tup=X_near[i]
				c_prime=tup[2]
				if c_prime < x_new[2]:
					x_min=tup
			i=i+1
		R_prime.add_edge(x_min,x_new)
		j=0
		while j< len(X_near):
			x_near=X_near[j]
			x=[x_near[0], x_near[1]]
			y=[x_new[0], x_new[1]]
			if(ObstacleFree(x_new,x_near,X_ob,Y_ob) and x_near[2] > x_new[2] + 
			math.dist(x,y)):
				x_parent=list(R_prime.predecessors(x_near))
				x_parent=x_parent[0]
				R_prime.remove_edge(x_parent,x_near)
				R_prime.add_edge(x_new,x_near)
			j=j+1
	return R_prime
#For testing FUNCTIONS
#for testing ObstacleFree
#x_of=[10,13]
#y_of=[14,13]
#boolean= ObstacleFree(x_of,y_of,X_ob,Y_ob)
#print(boolean)
#for testing Nearest function
#solution=Nearest(G,x)
#print(solution)
#For testing Steer function
#x=[5,7]
#y=[13,18]
#n=2 #step size
#g=Steer(x,y,n)
#print(g)
#For testing Sample function: This code plots the samples returned by Sample and the obstacles (shown in green)
#ans = Sample(X_cl, Y_cl, dim, 10)
#plt.plot(list(ans(1,:)),list(ans(2,:)), 'o')
#plt.plot(list(X_ob), list(Y_ob), 'o')
#plt.xlim(0,dim)
#plt.ylim(0,dim)
#plt.show()

#actual algorithm
x_init=[0,0,0]
R=nx.DiGraph()
i=0
N=500
R_prime=nx.DiGraph()
R_prime.add_node(tuple(x_init))
while i < N:
	R=R_prime
	x_rand=Sample(X_cl,Y_cl,dim,1)
	#print(x_rand)
	R_prime =Extend(R,x_rand,X_ob,Y_ob,2,dim)
	i=i+1
#plotting
#print("Nodes in the R:", R.nodes())
#print("Edges in the R:", R.edges())
W=nx.DiGraph()
new_nodes = [(n[0], n[1]) for n in R.nodes()]
W.add_nodes_from(new_nodes)
new_edges = [((n1[0], n1[1]), (n2[0], n2[1])) for n1, n2 in R.edges()]
W.add_edges_from(new_edges)

pos = nx.spring_layout(W) 
nx.draw(W, pos, with_labels=False, node_color='green', node_size=30, edge_color='black', font_size=8, font_weight='bold')
plt.show()
